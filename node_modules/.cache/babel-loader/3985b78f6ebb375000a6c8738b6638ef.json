{"ast":null,"code":"import _regeneratorRuntime from \"/Users/gyan/Documents/ProjectGyan/Hackathons/HackMoney/web3react-demo-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/gyan/Documents/ProjectGyan/Hackathons/HackMoney/web3react-demo-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/gyan/Documents/ProjectGyan/Hackathons/HackMoney/web3react-demo-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/gyan/Documents/ProjectGyan/Hackathons/HackMoney/web3react-demo-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nvar DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n};\nvar DEFAULT_HTTP_METHOD = \"POST\";\nvar DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD\n};\nexport var HttpConnection = /*#__PURE__*/function () {\n  function HttpConnection(url) {\n    _classCallCheck(this, HttpConnection);\n\n    this.url = url;\n    this.events = new EventEmitter();\n    this.isAvailable = false;\n    this.registering = false;\n\n    if (!isHttpUrl(url)) {\n      throw new Error(\"Provided URL is not compatible with HTTP connection: \".concat(url));\n    }\n\n    this.url = url;\n  }\n\n  _createClass(HttpConnection, [{\n    key: \"connected\",\n    get: function get() {\n      return this.isAvailable;\n    }\n  }, {\n    key: \"connecting\",\n    get: function get() {\n      return this.registering;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this.events.on(event, listener);\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, listener) {\n      this.events.once(event, listener);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this.events.off(event, listener);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(event, listener) {\n      this.events.removeListener(event, listener);\n    }\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var url,\n            _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                url = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.url;\n                _context.next = 3;\n                return this.register(url);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.isAvailable) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Connection already closed\");\n\n              case 2:\n                this.onClose();\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload, context) {\n        var body, res, data;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.isAvailable) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.register();\n\n              case 3:\n                _context3.prev = 3;\n                body = safeJsonStringify(payload);\n                _context3.next = 7;\n                return fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n                  body: body\n                }));\n\n              case 7:\n                res = _context3.sent;\n                _context3.next = 10;\n                return res.json();\n\n              case 10:\n                data = _context3.sent;\n                this.onPayload({\n                  data: data\n                });\n                _context3.next = 17;\n                break;\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t0 = _context3[\"catch\"](3);\n                this.onError(payload.id, _context3.t0);\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 14]]);\n      }));\n\n      function send(_x, _x2) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"register\",\n    value: function () {\n      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this = this;\n\n        var url,\n            body,\n            error,\n            _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                url = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : this.url;\n\n                if (isHttpUrl(url)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Provided URL is not compatible with HTTP connection: \".concat(url));\n\n              case 3:\n                if (!this.registering) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this.events.once(\"register_error\", function (error) {\n                    reject(error);\n                  });\n\n                  _this.events.once(\"open\", function () {\n                    if (typeof _this.isAvailable === \"undefined\") {\n                      return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n\n                    resolve();\n                  });\n                }));\n\n              case 5:\n                this.url = url;\n                this.registering = true;\n                _context4.prev = 7;\n                body = safeJsonStringify({\n                  id: 1,\n                  jsonrpc: \"2.0\",\n                  method: \"test\",\n                  params: []\n                });\n                _context4.next = 11;\n                return fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n                  body: body\n                }));\n\n              case 11:\n                this.onOpen();\n                _context4.next = 20;\n                break;\n\n              case 14:\n                _context4.prev = 14;\n                _context4.t0 = _context4[\"catch\"](7);\n                error = this.parseError(_context4.t0);\n                this.events.emit(\"register_error\", error);\n                this.onClose();\n                throw error;\n\n              case 20:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[7, 14]]);\n      }));\n\n      function register() {\n        return _register.apply(this, arguments);\n      }\n\n      return register;\n    }()\n  }, {\n    key: \"onOpen\",\n    value: function onOpen() {\n      this.isAvailable = true;\n      this.registering = false;\n      this.events.emit(\"open\");\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      this.isAvailable = false;\n      this.registering = false;\n      this.events.emit(\"close\");\n    }\n  }, {\n    key: \"onPayload\",\n    value: function onPayload(e) {\n      if (typeof e.data === \"undefined\") return;\n      var payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n      this.events.emit(\"payload\", payload);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(id, e) {\n      var error = this.parseError(e);\n      var message = error.message || error.toString();\n      var payload = formatJsonRpcError(id, message);\n      this.events.emit(\"payload\", payload);\n    }\n  }, {\n    key: \"parseError\",\n    value: function parseError(e) {\n      var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n      return parseConnectionError(e, url, \"HTTP\");\n    }\n  }]);\n\n  return HttpConnection;\n}();\nexport default HttpConnection;","map":{"version":3,"sources":["../../src/http.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError, } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n    headers: DEFAULT_HTTP_HEADERS,\n    method: DEFAULT_HTTP_METHOD,\n};\nexport class HttpConnection {\n    constructor(url) {\n        this.url = url;\n        this.events = new EventEmitter();\n        this.isAvailable = false;\n        this.registering = false;\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        this.url = url;\n    }\n    get connected() {\n        return this.isAvailable;\n    }\n    get connecting() {\n        return this.registering;\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async open(url = this.url) {\n        await this.register(url);\n    }\n    async close() {\n        if (!this.isAvailable) {\n            throw new Error(\"Connection already closed\");\n        }\n        this.onClose();\n    }\n    async send(payload, context) {\n        if (!this.isAvailable) {\n            await this.register();\n        }\n        try {\n            const body = safeJsonStringify(payload);\n            const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            const data = await res.json();\n            this.onPayload({ data });\n        }\n        catch (e) {\n            this.onError(payload.id, e);\n        }\n    }\n    async register(url = this.url) {\n        if (!isHttpUrl(url)) {\n            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n        }\n        if (this.registering) {\n            return new Promise((resolve, reject) => {\n                this.events.once(\"register_error\", error => {\n                    reject(error);\n                });\n                this.events.once(\"open\", () => {\n                    if (typeof this.isAvailable === \"undefined\") {\n                        return reject(new Error(\"HTTP connection is missing or invalid\"));\n                    }\n                    resolve();\n                });\n            });\n        }\n        this.url = url;\n        this.registering = true;\n        try {\n            const body = safeJsonStringify({ id: 1, jsonrpc: \"2.0\", method: \"test\", params: [] });\n            await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));\n            this.onOpen();\n        }\n        catch (e) {\n            const error = this.parseError(e);\n            this.events.emit(\"register_error\", error);\n            this.onClose();\n            throw error;\n        }\n    }\n    onOpen() {\n        this.isAvailable = true;\n        this.registering = false;\n        this.events.emit(\"open\");\n    }\n    onClose() {\n        this.isAvailable = false;\n        this.registering = false;\n        this.events.emit(\"close\");\n    }\n    onPayload(e) {\n        if (typeof e.data === \"undefined\")\n            return;\n        const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n        this.events.emit(\"payload\", payload);\n    }\n    onError(id, e) {\n        const error = this.parseError(e);\n        const message = error.message || error.toString();\n        const payload = formatJsonRpcError(id, message);\n        this.events.emit(\"payload\", payload);\n    }\n    parseError(e, url = this.url) {\n        return parseConnectionError(e, url, \"HTTP\");\n    }\n}\nexport default HttpConnection;\n//# sourceMappingURL=http.js.map"]},"metadata":{},"sourceType":"module"}